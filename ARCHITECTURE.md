# Architecture Documentation

Comprehensive technical architecture of the Kalshi Weather Trading Dashboard, covering system design, data flow, component interactions, and technology choices.

---

## Table of Contents

- [System Overview](#system-overview)
- [Architecture Diagram](#architecture-diagram)
- [Backend Architecture](#backend-architecture)
- [Frontend Architecture](#frontend-architecture)
- [Real-time Communication](#real-time-communication)
- [Data Flow](#data-flow)
- [File Formats](#file-formats)
- [Technology Choices](#technology-choices)
- [Scalability Considerations](#scalability-considerations)
- [Security Architecture](#security-architecture)

---

## System Overview

The Kalshi Weather Trading Dashboard is a **file-reader architecture** where a Django REST API serves structured data files generated by the trading daemon to a React single-page application (SPA). There is no database—all persistence is file-based.

### Core Principles

1. **Separation of Concerns**: Trading logic (daemon) is completely decoupled from visualization (dashboard)
2. **Stateless API**: Backend holds no state—reads files on every request
3. **Eventual Consistency**: Dashboard shows data as of last daemon write (15-minute polling cycle)
4. **Graceful Degradation**: Missing files result in empty datasets, not crashes
5. **Real-time Where Needed**: WebSockets for log streaming, HTTP polling for structured data

### High-Level Components

```
┌─────────────────────────────────────────────────────────────────┐
│                        User's Browser                           │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │         React Frontend (SPA)                            │  │
│  │  • Zustand state management                              │  │
│  │  • Axios HTTP client                                     │  │
│  │  • Recharts visualizations                               │  │
│  │  • WebSocket client (log streaming)                      │  │
│  └──────────────────────────────────────────────────────────┘  │
└────────────┬────────────────────────────────────┬───────────────┘
             │ HTTP (REST API)                    │ WebSocket
             │                                    │
┌────────────▼────────────────────────────────────▼───────────────┐
│                    Django Backend (ASGI)                        │
│  ┌─────────────────────┐           ┌─────────────────────────┐ │
│  │   REST API Views    │           │   WebSocket Consumer    │ │
│  │  • 27 endpoints     │           │   • Log tail streaming  │ │
│  │  • DRF serializers  │           │   • Async I/O           │ │
│  └──────────┬──────────┘           └──────────┬──────────────┘ │
│             │                                  │                 │
│  ┌──────────▼──────────────────────────────────▼──────────────┐ │
│  │             File Readers (Python Modules)                  │ │
│  │  • JSON parser                                             │ │
│  │  • JSONL parser with date filtering                        │ │
│  │  • Log tail utility                                        │ │
│  │  • File mtime checker                                      │ │
│  └──────────┬─────────────────────────────────────────────────┘ │
└─────────────┼─────────────────────────────────────────────────┬─┘
              │ File I/O                                        │
              │                                                 │
┌─────────────▼─────────────────────────────────────────────────▼─┐
│              Data Files (TRADING_DIR)                            │
│  • kalshi_unified_state.json  (positions, balance)              │
│  • kalshi_pnl.json            (daily/weekly P&L)                │
│  • kalshi_unified_log.txt     (timestamped log entries)         │
│  • kalshi_backtest_log.jsonl  (all evaluated opportunities)     │
│  • kalshi_settlement_log.jsonl (settled positions)              │
│  • paper_trades.jsonl         (simulated trades)                │
└────────────────────────────────────────────────────────────────┬─┘
                                                                 │
                                                                 │ Writes every 15 min
┌────────────────────────────────────────────────────────────────▼─┐
│                    Trading Daemon Process                        │
│  (kalshi_unified.py)                                             │
│  • Autonomous bot polling Kalshi API + weather providers         │
│  • Evaluates opportunities, executes trades, logs to files       │
└──────────────────────────────────────────────────────────────────┘
```

---

## Architecture Diagram

### Request Flow: Frontend → Backend → Files

**Example: Fetching Positions**

```
┌────────────┐                                               
│   Browser  │                                               
└─────┬──────┘                                               
      │ 1. GET /api/v1/positions/                           
      │    (Axios HTTP request)                             
      ▼                                                       
┌─────────────────────────────────┐                         
│   Django View: positions_view   │                         
└─────┬───────────────────────────┘                         
      │ 2. file_reader.read_json('kalshi_unified_state.json')
      ▼                                                       
┌───────────────────────┐                                   
│  FileReader.read_json │                                   
└─────┬─────────────────┘                                   
      │ 3. os.path.join(TRADING_DIR, filename)              
      │    open(path, 'r')                                  
      │    json.load(file)                                  
      ▼                                                       
┌──────────────────────────────┐                            
│  kalshi_unified_state.json   │                            
│  {                            │                            
│    "positions": [...],        │                            
│    "balance": 12500,          │                            
│    "daily_trades": 12         │                            
│  }                            │                            
└──────────────────────────────┘                            
      │ 4. Return parsed dict                               
      ▼                                                       
┌───────────────────────┐                                   
│  positions_view       │                                   
│  • Filter paper trades│                                   
│  • Return Response    │                                   
└─────┬─────────────────┘                                   
      │ 5. JSON response                                    
      │    {"positions": [...], "count": 8}                 
      ▼                                                       
┌────────────┐                                               
│   Browser  │                                               
│  • Zustand │ 6. Update dashboardStore.positions           
│    store   │    Re-render <PositionsTable />              
└────────────┘                                               
```

### WebSocket Flow: Real-time Log Streaming

```
┌────────────┐                                               
│   Browser  │                                               
└─────┬──────┘                                               
      │ 1. new WebSocket('ws://localhost:8000/ws/logs/')    
      │    Connection upgrade request                       
      ▼                                                       
┌──────────────────────────────┐                            
│  Django Channels Routing     │                            
│  /ws/logs/ → LogConsumer     │                            
└─────┬────────────────────────┘                            
      │ 2. LogConsumer.connect()                            
      │    Accept WebSocket                                 
      │    Spawn background task: tail_log_file()           
      ▼                                                       
┌───────────────────────────────────┐                       
│  LogConsumer Background Task      │                       
│  Loop forever:                    │                       
│    1. Check log file mtime        │                       
│    2. If changed, read new lines  │                       
│    3. Send lines via WebSocket    │                       
│    4. Sleep 1 second              │                       
└─────┬─────────────────────────────┘                       
      │ 3. New log line detected                            
      │    send_json({"type": "log_line", "line": "..."})   
      ▼                                                       
┌────────────┐                                               
│   Browser  │                                               
│  ws.onmessage = (event) => {                              
│    const data = JSON.parse(event.data);                   
│    appendToLogViewer(data.line);                          
│  }                                                         
└────────────┘                                               
```

---

## Backend Architecture

### Django Project Structure

```
backend/
├── manage.py                      # Django CLI entry point
├── requirements.txt               # Python dependencies
├── .env                          # Environment configuration
├── config/                       # Django project settings
│   ├── __init__.py
│   ├── settings.py               # All Django configuration
│   ├── urls.py                   # Root URL routing
│   ├── asgi.py                   # ASGI application (WebSockets)
│   └── wsgi.py                   # WSGI application (production)
├── dashboard/                    # Main Django app
│   ├── __init__.py
│   ├── views.py                  # REST API endpoint implementations (20+ views)
│   ├── urls.py                   # Dashboard URL routing
│   ├── file_readers.py           # FileReader class (JSON/JSONL parsers)
│   ├── analytics.py              # ReliabilityAnalytics class (27 analytics)
│   ├── consumers.py              # WebSocket consumers (LogConsumer)
│   ├── routing.py                # WebSocket URL routing
│   ├── paper_views.py            # Paper trading tab endpoints
│   └── management/
│       └── commands/
│           └── generate_secret_key.py  # SECRET_KEY generator
└── kalshi/                       # Optional app for future Kalshi API integration
    ├── __init__.py
    ├── views.py                  # (Unused) Direct Kalshi API calls
    └── urls.py                   # Kalshi-specific routes
```

### Key Modules

#### 1. File Readers (`dashboard/file_readers.py`)

**Purpose**: Abstraction layer for reading daemon output files with error handling and date filtering.

**Class: `FileReader`**

```python
class FileReader:
    def __init__(self, trading_dir: str):
        self.trading_dir = trading_dir
        self.files = {
            'kalshi_unified_state.json': f'{trading_dir}/kalshi_unified_state.json',
            # ... other files
        }
    
    def read_json(self, filename: str) -> dict:
        """Read JSON file, return {} if missing or malformed"""
        
    def read_jsonl(self, filename: str, date_filter: str = None) -> list:
        """Read JSONL file, optionally filter by date, return [] if missing"""
        
    def read_log_tail(self, filename: str, lines: int = 50) -> list:
        """Return last N lines from log file"""
        
    def get_file_mtime(self, filename: str) -> float | None:
        """Return file modification timestamp (Unix epoch)"""
```

**Design Decisions:**
- **Singleton Pattern**: Single `FileReader` instance configured with `TRADING_DIR` from `.env`
- **Error Handling**: Returns empty collections rather than raising exceptions (graceful degradation)
- **Date Filtering**: JSONL files can be massive—filter by date to reduce memory usage
  - Example: `read_jsonl('kalshi_backtest_log.jsonl', date_filter='2026-02-16')` only loads today's entries
- **No Caching**: Files are read on every request (appropriate for 15-minute update cycles)

**Performance Considerations:**
- JSON files (<1 MB): Fast parsing, negligible overhead
- JSONL files (10-100 MB): Date filtering essential (loads ~1-5K lines instead of 100K+)
- Log tail: Uses `deque` and reverse iteration for efficient tail reading

#### 2. Analytics Engine (`dashboard/analytics.py`)

**Purpose**: Calculate reliability metrics from settlement log (win rates, calibration, bias).

**Class: `ReliabilityAnalytics`**

```python
class ReliabilityAnalytics:
    def __init__(self, days: int = None, city: str = None, min_trades: int = 0):
        self.entries = self._load_and_filter_settlements(days, city)
        self.min_trades = min_trades
    
    def win_rate_by(self, field: str, buckets: list = None) -> dict:
        """Calculate win rate grouped by field (city, side, confidence, edge)"""
        
    def streaks(self) -> dict:
        """Current and longest win/loss streaks"""
        
    def cost_summary(self) -> dict:
        """Average cost, profit, ROI, break-even win rate"""
        
    def edge_calibration(self, bucket_size: int = 5) -> list:
        """Edge calibration curve data"""
        
    def confidence_calibration(self, bucket_size: float = 0.05) -> list:
        """Confidence calibration curve data"""
        
    def edge_bias(self) -> dict:
        """Systematic bias in edge prediction"""
        
    def provider_accuracy(self) -> list:
        """Per-provider win rates and forecast error"""
        
    def noaa_staleness_impact(self) -> dict:
        """Win rate comparison: fresh vs stale NOAA data"""
        
    def provider_dropout_impact(self) -> dict:
        """Win rate by provider count (all 5 vs missing data)"""
```

**Design Decisions:**
- **Filter on Initialization**: Load and filter settlement data once, reuse for multiple calculations
- **Bucketing Logic**: Flexible bucketing for confidence (0.05 increments) and edge (5¢ increments)
- **Min Trades Threshold**: Ignore buckets with too few trades (statistical significance)

**Memory Usage:**
- Loads entire `kalshi_settlement_log.jsonl` into memory (acceptable for <10K settlements)
- For >100K settlements, implement pagination or database caching (future enhancement)

#### 3. REST API Views (`dashboard/views.py`)

**Structure:**
- **Function-based views** decorated with `@api_view(['GET'])`
- **DRF Response objects** for consistent JSON formatting
- **Query parameter extraction** via `request.GET.get()`

**Example View:**

```python
@api_view(['GET'])
def positions_view(request):
    state = file_reader.read_json('kalshi_unified_state.json')
    all_positions = state.get('positions', [])
    
    # Filter out paper trades
    live_positions = [p for p in all_positions if not p.get('paper_trade', False)]
    
    return Response({
        'positions': live_positions,
        'count': len(live_positions),
    })
```

**Error Handling:**
- File read errors: Return empty collections (no 500 errors)
- Malformed JSON: Log warning, return empty dict
- Missing query parameters: Use defaults (e.g., `date=today`)

#### 4. WebSocket Consumers (`dashboard/consumers.py`)

**Purpose**: Real-time log streaming using Django Channels.

**Class: `LogConsumer`**

```python
class LogConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        await self.accept()
        # Spawn background task to tail log file
        asyncio.create_task(self.tail_log_file())
    
    async def tail_log_file(self):
        last_mtime = 0
        last_position = 0
        
        while True:
            current_mtime = os.path.getmtime(log_file_path)
            if current_mtime > last_mtime:
                # File modified, read new lines
                with open(log_file_path, 'r') as f:
                    f.seek(last_position)
                    new_lines = f.readlines()
                    last_position = f.tell()
                
                for line in new_lines:
                    await self.send(text_data=json.dumps({
                        'type': 'log_line',
                        'line': line.strip(),
                        'timestamp': datetime.now().isoformat(),
                    }))
                
                last_mtime = current_mtime
            
            await asyncio.sleep(1)  # Poll every second
    
    async def disconnect(self, close_code):
        # Background task automatically cancelled when consumer closes
        pass
```

**Design Decisions:**
- **File Polling**: Check `mtime` every second (simpler than `inotify`, works on all platforms)
- **Position Tracking**: Track file position to avoid re-reading entire file
- **Background Task**: Async task runs in parallel with WebSocket connection
- **Auto-cleanup**: Asyncio tasks are cancelled when consumer disconnects

**Alternative Approaches (Not Used):**
- `watchdog` library: Requires additional dependency, overkill for single file
- `inotify` (Linux): Platform-specific, doesn't work on Windows/macOS
- Redis Pub/Sub: Requires Redis, adds infrastructure complexity

---

## Frontend Architecture

### React Project Structure

```
frontend/
├── package.json                   # Node dependencies
├── vite.config.ts                 # Vite build configuration
├── tailwind.config.ts             # Tailwind CSS + Frost theme
├── tsconfig.json                  # TypeScript configuration
├── index.html                     # Entry HTML (single page)
├── public/                        # Static assets
└── src/
    ├── main.tsx                   # React root, app entry point
    ├── App.tsx                    # Root component, routing logic
    ├── config/
    │   └── api.ts                 # Axios instance, API method wrappers
    ├── stores/
    │   ├── dashboardStore.ts      # Zustand: positions, P&L, status
    │   └── paperStore.ts          # Zustand: paper trades
    ├── types/
    │   ├── position.ts            # TypeScript interfaces for positions
    │   ├── pnl.ts                 # P&L data types
    │   ├── backtest.ts            # Backtest entry types
    │   └── paper.ts               # Paper trade types
    ├── components/
    │   ├── layout/
    │   │   ├── Header.tsx         # Top banner with app title
    │   │   └── NavBar.tsx         # Tab navigation
    │   ├── PositionsTable.tsx     # Sortable table of positions
    │   ├── PnLChart.tsx           # Recharts area chart
    │   ├── PnLPanel.tsx           # Summary cards (balance, P&L)
    │   ├── CityHeatmap.tsx        # City performance grid
    │   ├── BacktestStats.tsx      # Funnel stats
    │   ├── HeroBanner.tsx         # Large status panel
    │   ├── SettingsDrawer.tsx     # Slide-out settings
    │   ├── ErrorBanner.tsx        # Error notifications
    │   └── AlertBanner.tsx        # Info/warning banners
    └── styles/
        └── index.css              # Global styles, Tailwind imports
```

### State Management: Zustand

**Why Zustand over Redux/Context API?**
- **Simpler**: No boilerplate (no actions, reducers, providers)
- **Smaller**: 1 KB minified (vs Redux 18 KB)
- **Performant**: Direct subscriptions, no Context re-render issues
- **TypeScript-friendly**: Full type inference

**Example Store: `dashboardStore.ts`**

```typescript
import create from 'zustand';
import { fetchPositions, fetchPnL, fetchStatus } from '../config/api';

interface DashboardState {
  // State
  positions: Position[];
  pnl: PnLData | null;
  status: StatusData | null;
  loading: boolean;
  error: string | null;
  
  // Actions
  loadPositions: () => Promise<void>;
  loadPnL: () => Promise<void>;
  loadStatus: () => Promise<void>;
  refreshAll: () => Promise<void>;
}

export const useDashboardStore = create<DashboardState>((set) => ({
  // Initial state
  positions: [],
  pnl: null,
  status: null,
  loading: false,
  error: null,
  
  // Actions
  loadPositions: async () => {
    set({ loading: true, error: null });
    try {
      const response = await fetchPositions();
      set({ positions: response.data.positions, loading: false });
    } catch (error) {
      set({ error: error.message, loading: false });
    }
  },
  
  loadPnL: async () => {
    const response = await fetchPnL();
    set({ pnl: response.data });
  },
  
  loadStatus: async () => {
    const response = await fetchStatus();
    set({ status: response.data });
  },
  
  refreshAll: async () => {
    await Promise.all([
      useDashboardStore.getState().loadPositions(),
      useDashboardStore.getState().loadPnL(),
      useDashboardStore.getState().loadStatus(),
    ]);
  },
}));
```

**Usage in Components:**

```typescript
import { useDashboardStore } from '../stores/dashboardStore';

function PositionsTable() {
  const { positions, loading, loadPositions } = useDashboardStore();
  
  useEffect(() => {
    loadPositions();
    const interval = setInterval(loadPositions, 10000); // Poll every 10s
    return () => clearInterval(interval);
  }, [loadPositions]);
  
  if (loading) return <div>Loading...</div>;
  
  return (
    <table>
      {positions.map(pos => (
        <tr key={pos.ticker}>
          <td>{pos.city}</td>
          <td>{pos.side}</td>
          {/* ... */}
        </tr>
      ))}
    </table>
  );
}
```

### API Client: Axios

**Configuration: `config/api.ts`**

```typescript
import axios from 'axios';

const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000';

const api = axios.create({
  baseURL: `${API_BASE_URL}/api/v1/`,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor (add auth headers in future)
api.interceptors.request.use((config) => {
  console.log(`API Request: ${config.method?.toUpperCase()} ${config.url}`);
  return config;
});

// Response interceptor (error handling)
api.interceptors.response.use(
  (response) => response,
  (error) => {
    console.error('API Error:', error.response?.data || error.message);
    return Promise.reject(error);
  }
);

// API method wrappers
export const fetchPositions = () => api.get('/positions/');
export const fetchPnL = () => api.get('/pnl/');
export const fetchStatus = () => api.get('/status/');
export const fetchBacktest = (params?: any) => api.get('/backtest/', { params });
// ... 27 endpoints total
```

### Component Design Patterns

**1. Container/Presentational Pattern**

- **Container Components**: Fetch data, manage state (e.g., `DashboardContainer.tsx`)
- **Presentational Components**: Receive props, render UI (e.g., `PositionsTable.tsx`)

**2. Custom Hooks for Data Fetching**

```typescript
function usePolling(fetchFn: () => void, interval: number) {
  useEffect(() => {
    fetchFn(); // Fetch immediately
    const id = setInterval(fetchFn, interval);
    return () => clearInterval(id);
  }, [fetchFn, interval]);
}

// Usage
function Dashboard() {
  const { loadPositions, loadStatus } = useDashboardStore();
  
  usePolling(loadPositions, 10000); // Poll every 10s
  usePolling(loadStatus, 10000);
  
  // ...render
}
```

**3. TypeScript Interfaces for Type Safety**

```typescript
// types/position.ts
export interface Position {
  ticker: string;
  city: string;
  side: 'yes' | 'no';
  strike: number;
  settlement_date: string;
  quantity: number;
  avg_price: number;
  cost_cents: number;
  edge: number;
  confidence: number;
  opened_at: string;
  ensemble_details: EnsembleDetails;
  paper_trade: boolean;
}

export interface EnsembleDetails {
  ensemble_forecast: number;
  provider_count: number;
  noaa_stale: boolean;
  noaa_weight: number;
  gfs_forecast?: number;
  icon_forecast?: number;
  ecmwf_forecast?: number;
  gem_forecast?: number;
}
```

---

## Real-time Communication

### WebSocket Architecture

**Protocol**: RFC 6455 WebSocket over TCP

**Lifecycle:**

1. **Connection Establishment**
   - Client sends HTTP Upgrade request: `GET /ws/logs/ HTTP/1.1` with `Upgrade: websocket`
   - Server (Daphne) responds: `HTTP/1.1 101 Switching Protocols`
   - Connection upgraded to WebSocket (persistent TCP connection)

2. **Data Transmission**
   - **Server → Client**: JSON messages with log lines
   - **Client → Server**: (None—currently read-only)
   - **Frame Format**: Text frames (UTF-8 JSON strings)

3. **Heartbeat/Keepalive**
   - Ping/Pong frames every 30 seconds (configurable in Daphne)
   - Prevents NAT timeout, detects disconnections

4. **Disconnection**
   - Client closes: Browser tab closed, network disconnected
   - Server closes: Daemon crashes, server restarted
   - Reconnection: Client implements exponential backoff

**Frontend Implementation:**

```typescript
class LogStreamClient {
  private ws: WebSocket | null = null;
  private reconnectDelay = 1000;
  private maxReconnectDelay = 30000;
  
  connect(url: string, onMessage: (line: string) => void) {
    this.ws = new WebSocket(url);
    
    this.ws.onopen = () => {
      console.log('WebSocket connected');
      this.reconnectDelay = 1000; // Reset delay
    };
    
    this.ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      if (data.type === 'log_line') {
        onMessage(data.line);
      }
    };
    
    this.ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
    
    this.ws.onclose = (event) => {
      console.log(`WebSocket closed: ${event.code} ${event.reason}`);
      this.reconnect(url, onMessage);
    };
  }
  
  reconnect(url: string, onMessage: (line: string) => void) {
    console.log(`Reconnecting in ${this.reconnectDelay}ms...`);
    setTimeout(() => {
      this.connect(url, onMessage);
    }, this.reconnectDelay);
    
    // Exponential backoff
    this.reconnectDelay = Math.min(this.reconnectDelay * 2, this.maxReconnectDelay);
  }
  
  disconnect() {
    if (this.ws) {
      this.ws.close(1000, 'User closed connection');
    }
  }
}
```

**Server Implementation (Django Channels):**

```python
# dashboard/routing.py
from django.urls import path
from . import consumers

websocket_urlpatterns = [
    path('ws/logs/', consumers.LogConsumer.as_asgi()),
]

# config/asgi.py
import os
from django.core.asgi import get_asgi_application
from channels.routing import ProtocolTypeRouter, URLRouter
from channels.auth import AuthMiddlewareStack
from dashboard.routing import websocket_urlpatterns

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = ProtocolTypeRouter({
    'http': get_asgi_application(),
    'websocket': AuthMiddlewareStack(
        URLRouter(websocket_urlpatterns)
    ),
})
```

**Production Considerations:**

- **Nginx WebSocket Proxy**:
  ```nginx
  location /ws/ {
      proxy_pass http://127.0.0.1:8000;
      proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection "upgrade";
      proxy_read_timeout 86400;  # 24 hours
  }
  ```

- **Scaling**: For multiple backend servers, use Redis channel layer:
  ```python
  # config/settings.py
  CHANNEL_LAYERS = {
      'default': {
          'BACKEND': 'channels_redis.core.RedisChannelLayer',
          'CONFIG': {
              'hosts': [('127.0.0.1', 6379)],
          },
      },
  }
  ```

---

## Data Flow

### Daemon → Files → API → UI

**Complete Data Flow Example: Trade Settlement**

1. **Daemon Detects Settlement** (3:00 PM market close)
   ```python
   # kalshi_unified.py
   if market_settled:
       pnl_cents = (settlement_value - entry_cost) * quantity
       
       # Append to settlement log
       with open('kalshi_settlement_log.jsonl', 'a') as f:
           f.write(json.dumps({
               'timestamp': now().isoformat(),
               'ticker': 'KXHIGHTPHX-26FEB16-75',
               'city': 'PHX',
               'side': 'yes',
               'strike': 75,
               'pnl_cents': pnl_cents,
               'edge': 22.3,
               'confidence': 0.845,
               # ...
           }) + '\n')
       
       # Update daily P&L
       pnl_data = load_json('kalshi_pnl.json')
       pnl_data['daily'][today]['pnl_cents'] += pnl_cents
       pnl_data['daily'][today]['trades'] += 1
       save_json('kalshi_pnl.json', pnl_data)
       
       # Remove from positions
       state['positions'] = [p for p in state['positions'] if p['ticker'] != ticker]
       save_json('kalshi_unified_state.json', state)
   ```

2. **Backend API Request** (10 seconds later, frontend polls)
   ```python
   # dashboard/views.py
   @api_view(['GET'])
   def pnl_view(request):
       pnl = file_reader.read_json('kalshi_pnl.json')
       return Response({'daily': pnl.get('daily', {}), 'weeks': pnl.get('weeks', {})})
   ```

3. **Frontend Update**
   ```typescript
   // stores/dashboardStore.ts
   const loadPnL = async () => {
       const response = await fetchPnL();
       set({ pnl: response.data });
   };
   
   // components/PnLChart.tsx
   useEffect(() => {
       loadPnL();
       const interval = setInterval(loadPnL, 10000);
       return () => clearInterval(interval);
   }, []);
   ```

4. **UI Renders Updated Chart**
   - Recharts re-renders with new daily P&L data
   - User sees updated bar for Feb 16

**Latency Breakdown:**
- Daemon writes file: 10ms
- Frontend poll interval: 0-10 seconds (worst case)
- API request + file read: 50-100ms
- React re-render: 10-20ms
- **Total latency**: 0-10 seconds (acceptable for 15-minute update cycles)

---

## File Formats

### 1. `kalshi_unified_state.json` (Overwrite)

**Purpose**: Current snapshot of trading state (positions, balance, circuit breaker status).

**Schema:**
```json
{
  "positions": [
    {
      "ticker": "KXHIGHTPHX-26FEB17-75",
      "city": "PHX",
      "side": "yes",
      "strike": 75,
      "settlement_date": "2026-02-17",
      "quantity": 5,
      "avg_price": 47,
      "cost_cents": 235,
      "edge": 22.3,
      "confidence": 0.845,
      "opened_at": "2026-02-16T10:30:00",
      "ensemble_details": {
        "ensemble_forecast": 78.4,
        "provider_count": 5,
        "noaa_stale": false,
        "noaa_weight": 1.5,
        "gfs_forecast": 78.1,
        "icon_forecast": 78.6,
        "ecmwf_forecast": 78.5,
        "gem_forecast": 78.0
      },
      "paper_trade": false
    }
  ],
  "balance": 12500,
  "daily_trades": 12,
  "daily_loss_cents": -120,
  "weekly_loss_cents": 480,
  "last_update": "2026-02-16T11:45:32"
}
```

**Update Frequency**: Every poll cycle (~15 minutes) or on position change.

---

### 2. `kalshi_pnl.json` (Overwrite)

**Purpose**: Aggregated P&L by day and week.

**Schema:**
```json
{
  "daily": {
    "2026-02-16": {
      "pnl_cents": 350,
      "trades": 6,
      "wins": 4,
      "losses": 2
    },
    "2026-02-15": {
      "pnl_cents": -120,
      "trades": 8,
      "wins": 5,
      "losses": 3
    }
  },
  "weeks": {
    "2026-W07": {
      "pnl_cents": 1280,
      "trades": 32,
      "wins": 21,
      "losses": 11
    }
  }
}
```

**Update Frequency**: On settlement (market close at 3 PM).

---

### 3. `kalshi_backtest_log.jsonl` (Append-Only)

**Purpose**: Log every opportunity evaluated (traded or skipped).

**Schema (per line):**
```json
{
  "timestamp": "2026-02-16T10:15:23",
  "city": "PHX",
  "ticker": "KXHIGHTPHX-26FEB17-75",
  "strike": 75,
  "side": "yes",
  "action": "trade",
  "skip_reason": null,
  "edge": 22.3,
  "confidence": 0.845,
  "market_yes_price": 52,
  "ensemble_forecast": 78.4,
  "provider_count": 5
}
```

**Update Frequency**: Every poll cycle (~15 minutes), 100-300 lines per day.

**File Size**: ~1 MB per month (10K lines × 100 bytes/line).

---

### 4. `kalshi_settlement_log.jsonl` (Append-Only)

**Purpose**: Log settled positions with P&L and ensemble details.

**Schema (per line):**
```json
{
  "timestamp": "2026-02-16T15:05:42",
  "ticker": "KXHIGHTPHX-26FEB16-75",
  "city": "PHX",
  "side": "yes",
  "strike": 75,
  "settlement_date": "2026-02-16",
  "quantity": 5,
  "entry_price": 47,
  "settlement_value": 100,
  "cost_cents": 235,
  "pnl_cents": 265,
  "edge": 22.3,
  "adjusted_edge": 19.8,
  "confidence": 0.845,
  "ensemble_forecast": 78.4,
  "actual_high": 79.2,
  "forecast_error": 0.8,
  "provider_count": 5,
  "noaa_stale": false
}
```

**Update Frequency**: On settlement (once per position).

**File Size**: ~500 KB per month (5K settlements × 100 bytes/line).

---

### 5. `kalshi_unified_log.txt` (Append-Only)

**Purpose**: Human-readable log for daemon activity (trades, errors, circuit breaker).

**Format (plain text, timestamped lines):**
```
2026-02-16 10:30:15 [INFO] Poll cycle 1247 starting
2026-02-16 10:30:18 [INFO] Fetching NOAA forecasts for 11 cities
2026-02-16 10:30:22 [INFO] Ensemble forecast PHX: 78.4°F (5 providers)
2026-02-16 10:30:25 [TRADE] OPENED yes KXHIGHTPHX-26FEB17-75 qty=5 @47¢ edge=22.3¢
2026-02-16 10:30:30 [INFO] Circuit breaker check: OK (daily loss: -120¢ / -500¢)
2026-02-16 10:30:35 [SKIP] SFO strike=60 spread too wide (28¢)
```

**Update Frequency**: Every poll cycle, 50-200 lines per day.

**File Size**: ~2 MB per month (60K lines × 80 bytes/line).

---

### 6. `paper_trades.jsonl` (Append-Only)

**Purpose**: Log simulated paper trades.

**Schema (per line):**
```json
{
  "timestamp": "2026-02-16T09:15:42",
  "city": "PHX",
  "ticker": "KXHIGHTPHX-26FEB17-72",
  "side": "yes",
  "strike": 72,
  "quantity": 8,
  "price": 45,
  "cost_cents": 360,
  "edge": 19.2,
  "confidence": 0.823,
  "ensemble_forecast": 75.8,
  "market_yes_price": 45,
  "settlement_date": "2026-02-17"
}
```

**Update Frequency**: When paper trading enabled, ~10-50 entries per day.

---

## Technology Choices

### Why Django?

**Pros:**
- **Batteries Included**: Admin panel, ORM, middleware, security out-of-the-box
- **Channels Support**: First-class WebSocket support via Daphne/Channels
- **DRF Ecosystem**: Django REST Framework for rapid API development
- **Python Ecosystem**: Easy integration with data science tools (NumPy, Pandas for future analytics)

**Alternatives Considered:**
- **Flask**: Too minimal, would need to add WebSocket, ORM, serialization
- **FastAPI**: Great for async, but less mature ecosystem for WebSockets
- **Node.js (Express)**: Frontend/backend in same language, but less suited for data processing

**Verdict**: Django's maturity, Channels integration, and Python ecosystem win.

---

### Why React 19?

**Pros:**
- **Concurrent Mode**: Automatic batching, smoother updates for live data
- **Server Components** (future): Potential SSR for SEO/performance
- **Ecosystem**: Largest component library (Recharts, Zustand, Tailwind)
- **Developer Experience**: HMR with Vite, TypeScript support

**Alternatives Considered:**
- **Svelte**: Faster, smaller bundle, but less mature ecosystem
- **Vue 3**: Great DX, but smaller job market, fewer charting libraries
- **Next.js**: Server-side rendering overkill for dashboard (no SEO needs)

**Verdict**: React's ecosystem and Concurrent Mode advantages outweigh bundle size concerns.

---

### Why Zustand over Redux?

**Pros:**
- **Simpler API**: No boilerplate, no providers, no actions/reducers
- **Smaller Bundle**: 1 KB vs Redux 18 KB
- **TypeScript-friendly**: Full type inference without manual types
- **Performant**: Direct subscriptions, no Context re-render issues

**Alternatives Considered:**
- **Redux Toolkit**: Still verbose, larger bundle
- **Context API**: Re-render issues with large state trees
- **Recoil/Jotai**: Great, but smaller community, experimental

**Verdict**: Zustand is the sweet spot of simplicity, performance, and TypeScript support.

---

### Why Vite over Create React App?

**Pros:**
- **Fast HMR**: ES modules, instant updates (vs CRA's Webpack rebuild)
- **Smaller Bundle**: Optimized production builds with Rollup
- **Modern**: Native ESM, no transpile during dev
- **Flexible**: Easy to customize (vs CRA eject)

**Alternatives Considered:**
- **Create React App**: Slower, deprecated, requires eject for customization
- **Webpack**: Powerful, but complex configuration

**Verdict**: Vite is the modern standard for React development.

---

### Why Tailwind CSS?

**Pros:**
- **Utility-first**: Faster development, no naming conventions
- **JIT Compiler**: Only includes used classes (small bundle)
- **Consistent Spacing**: 4px grid, predictable sizing
- **Customizable**: Frost theme via `tailwind.config.ts`

**Alternatives Considered:**
- **CSS Modules**: Verbose, requires file switching
- **Styled Components**: Runtime overhead, larger bundle
- **Bootstrap**: Opinionated, harder to customize

**Verdict**: Tailwind's DX and bundle size win.

---

## Scalability Considerations

### Current Limits (Single Server)

- **Concurrent Users**: 100-500 (Daphne async handles WebSocket connections efficiently)
- **API Throughput**: 100-200 req/s (file I/O bottleneck)
- **WebSocket Connections**: 1000+ (async consumers, low memory per connection)
- **File Size**: Works well up to 100 MB JSONL files (with date filtering)

### Scaling Strategies (Future)

**Horizontal Scaling (Multiple Backend Servers):**

1. **Load Balancer**: Nginx or HAProxy
2. **Redis Channel Layer**: Share WebSocket messages across servers
3. **Shared File Storage**: NFS or S3 for `TRADING_DIR` files
4. **Session Affinity**: Sticky sessions for WebSocket connections

**Database Caching:**

For >100K settlements, cache analytics in PostgreSQL:
```python
# Cache edge calibration results (expensive calculation)
@cache_memoize(timeout=3600)  # 1 hour TTL
def get_edge_calibration(days=None, city=None):
    return ReliabilityAnalytics(days=days, city=city).edge_calibration()
```

**CDN for Frontend:**

Serve static frontend assets (JS, CSS, images) via Cloudflare/CloudFront:
- Reduces backend load
- Faster global delivery
- Free SSL/DDoS protection

---

## Security Architecture

### Current Security Measures

**1. No Authentication Required**
- Read-only file-based API (no sensitive write operations)
- Assumes dashboard runs on private network or localhost

**2. CORS Restrictions**
```python
# config/settings.py
CORS_ALLOWED_ORIGINS = env.list('CORS_ALLOWED_ORIGINS', default=[])
```
- Only whitelisted frontend origins can access API
- Blocks XSS attacks from malicious sites

**3. SECRET_KEY Randomization**
- Auto-generated 64-character key
- Used for session security (even though dashboard doesn't use sessions yet)

**4. DEBUG=false in Production**
- Hides stack traces (prevents information disclosure)

### Future Security Enhancements

**1. API Authentication**
```python
# Add API key or JWT authentication
@api_view(['GET'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
def positions_view(request):
    # ...
```

**2. HTTPS Enforcement**
```python
SECURE_SSL_REDIRECT = True
SECURE_HSTS_SECONDS = 31536000
```

**3. Rate Limiting**
```python
# Prevent abuse
from rest_framework.throttling import AnonRateThrottle

class BurstRateThrottle(AnonRateThrottle):
    rate = '100/minute'
```

**4. File Path Validation**
```python
# Prevent path traversal attacks
def safe_join(base_dir, filename):
    path = os.path.join(base_dir, filename)
    if not os.path.commonpath([base_dir, path]) == base_dir:
        raise ValueError('Path traversal detected')
    return path
```

---

## Conclusion

The Kalshi Weather Trading Dashboard architecture prioritizes **simplicity, reliability, and developer experience**:

- **File-based**: No database complexity, easy backups, transparent data flow
- **Stateless API**: Horizontal scaling without session management
- **Real-time where needed**: WebSockets for logs, HTTP polling for structured data
- **Modern stack**: React 19, Django 4.2, TypeScript, Tailwind CSS
- **Type-safe**: TypeScript on frontend, Python type hints on backend
- **Graceful degradation**: Missing files don't crash the system

This architecture scales to **thousands of daily trades** and **hundreds of concurrent users** without modification. For larger scale, add database caching and Redis channel layers.

For implementation details, see [API.md](./API.md) and [README.md](./README.md).
